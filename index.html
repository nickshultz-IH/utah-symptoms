<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Intermountain Health</title>
  <meta name="description" content="MapLibre + Google Sheets + clustering with Atlist-style sidebar and Intermountain styling." />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;600;700&family=Source+Sans+3:wght@400;600&display=swap" rel="stylesheet">

  <!-- MapLibre GL -->
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

  <style>
    :root{
      --sidebar-w: 380px;
      --accent: #4A00E2;
      --dark: #110057;
      --muted:#6b7280;
      --chip:#F7F5F9;
      --fade:.35;
      --iw-w: 380px;
      --iw-w-sm: 320px;
    }

    html, body { height: 100%; margin: 0; color: var(--dark); font-family: 'Source Sans 3', Arial, sans-serif; }
    h1, h2, h3, h4, .btn, .chip { font-family: 'Inter', Arial, sans-serif; }

    .app { height: 100vh; display: grid; grid-template-columns: var(--sidebar-w) 1fr; }
    .sidebar { height: 100%; overflow: hidden; border-right: 1px solid #e5e7eb; display: flex; flex-direction: column; background: #fff; }
    .sidebar header { padding: 16px 16px 8px; border-bottom: 1px solid #e5e7eb; position: relative; }
    .sidebar h1 { margin: 0 0 6px; font-size: 20px; font-weight: 700; }
    .meta { color: var(--muted); font-size: 12px; }

    .controls { padding: 12px 16px; border-bottom: 1px solid #e5e7eb; gap: 8px; display: grid; grid-template-columns: 1fr; background: #fff; }
    .row { display:flex; gap:8px; align-items:center; }
    .row > * { flex:1; }
    .search input { width:100%; padding: 10px 12px; border: 1px solid #d1d5db; border-radius: 10px; font-size: 14px; }
    .btn { appearance:none; border:1px solid #d1d5db; background:#fff; border-radius:10px; padding:8px 10px; font-size:13px; cursor:pointer; }

    .filters { padding:10px 16px; overflow:auto; border-bottom:1px solid #e5e7eb; max-height:30%; background:#fff; }
    .filters h3 { margin:10px 0 8px; font-size:12px; color:var(--muted); text-transform:uppercase; letter-spacing:.06em; }
    .chips { display:flex; flex-wrap:wrap; gap:6px; }
    .chip { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; background:var(--chip); border:1px solid #e5e7eb; border-radius:999px; font-size:12px; cursor:pointer; user-select:none; }

    .list { overflow:auto; flex:1; background:#fff; }

    /* Group (accordion) */
    .group-section { border-top:1px solid #eee; }
    .group-head {
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px 10px 16px; font-size:13px; color:#374151; font-weight:600;
      text-transform:uppercase; letter-spacing:.04em; background:#fafafa;
      position:sticky; top:0; z-index:1; border-bottom:1px solid #f0f0f0;
    }
    .group-head .left { display:flex; align-items:center; gap:8px; }
    .group-head .controls { display:flex; gap:8px; align-items:center; }
    .pill { display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; background:#eef; color:#223; font-size:11px; border:1px solid #dde; }
    .iconbtn { appearance:none; border:none; background:transparent; padding:4px; cursor:pointer; color:#374151; border-radius:6px; }
    .iconbtn:hover { background:#efefef; }
    .chev{ transition:transform .18s ease; }
    .collapsed .chev { transform: rotate(90deg); }
    .faded{ opacity: var(--fade); }

    .group-body { display:block; }
    .collapsed + .group-body { display:none; }

    .card { border-bottom:1px solid #f3f4f6; padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px; }
    .card:hover { background:#f9fafb; }
    .card h4 { margin:0 0 2px; font-size:15px; }
    .pin-img { width:20px; height:20px; flex:0 0 20px; object-fit:contain; }
    .meta-row { color:var(--muted); font-size:12px; }

    #map { height:100%; width:100%; position:relative; }

    /* MapLibre popup */
    .maplibregl-popup { z-index: 2000; }
    .maplibregl-popup-content {
      padding: 0 !important;
      width: var(--iw-w);
      max-width: none !important;
      border-radius: 10px;
      box-shadow: 0 8px 20px rgba(0,0,0,.15);
      overflow: hidden;
      font-family: 'Source Sans 3', Arial, sans-serif;
    }
    .iw .hero { position:relative; width:100%; height:150px; overflow:hidden; }
    .iw .hero img { width:100%; height:100%; object-fit:cover; }
    .iw .tagpill { position:absolute; top:10px; left:10px; background:#fff; color:#111827; font-size:12px; padding:4px 10px; border-radius:999px; border:1px solid #e5e7eb; }
    .iw .pad { padding:12px 14px 14px; }
    .iw h3 { margin:10px 0 4px; font-size:18px; font-weight:700; }
    .iw .group { color:#374151; font-size:13px; margin-bottom:8px; }
    .iw .addr { margin-bottom:8px; }
    .iw .addr-link { font-size:15px; font-weight:600; color:#110057; text-decoration:underline; }
    .iw .addr-link:hover { text-decoration:none; }
    .iw .btn-learn {
      display:block; width:100%; box-sizing:border-box; text-align:center;
      padding:12px 14px; background:#110057; color:#fff; border-radius:10px;
      text-decoration:none; font-family:'Inter', Arial, sans-serif; font-weight:600;
      margin-top:10px; white-space:normal; overflow:hidden; text-overflow:ellipsis;
    }

    /* Icon-only controls */
    .icon-btn { border:none; background:none; padding:6px; border-radius:6px; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; color:var(--dark); }
    .icon-btn:hover { background:#f3f4f6; }
    .icon-btn svg { width:18px; height:18px; }
    /* smaller variant for compact icon buttons */
.iconbtn.small { padding: 2px; }
.iconbtn.small svg { width: 14px; height: 14px; }

    /* Mobile drawer */
    .menu-btn {
      display:none; position:absolute; top:10px; left:10px; z-index:1100;
      background:#110057; color:#fff; border:none; padding:10px 12px; border-radius:6px; box-shadow:0 2px 6px rgba(0,0,0,.2);
    }
    .menu-btn:focus { outline:2px solid #4A00E2; outline-offset:2px; }
    .backdrop { display:none; position:fixed; inset:0; background:rgba(0,0,0,.4); z-index:999; }
    .backdrop.show { display:block; }

    /* Desktop sidebar toggle */
    @media (min-width: 769px) { .desk-toggle { display:inline-flex; } }
    .desk-toggle {
      position:absolute; top:8px; right:12px; z-index:3000; background:#110057; color:#fff; border:none;
      padding:8px 10px; border-radius:6px; box-shadow:0 2px 6px rgba(0,0,0,.2); gap:6px; cursor:pointer; display:inline-flex;
    }
    .desk-toggle .icon { transition: transform .2s ease; }
    .desk-toggle-floating { position:fixed !important; top:12px !important; left:12px !important; right:auto !important; z-index:3000 !important; display:inline-flex !important; }
    .desk-toggle .icon.flipped { transform: rotate(180deg); }

    .app .sidebar { transition: transform .3s ease; }
    .app.sidebar-collapsed { grid-template-columns: 0 1fr !important; }
    .app.sidebar-collapsed .sidebar { transform: translateX(-100%); }
    .app.sidebar-collapsed .desk-toggle { position:fixed !important; top:12px !important; left:12px !important; right:auto !important; }
    .app.sidebar-collapsed .desk-toggle .icon { transform: rotate(180deg); }

    /* Responsive */
    @media (max-width: 768px){
      .app { grid-template-columns: 1fr; }
      .sidebar {
        position:fixed; top:0; left:0; height:100%; width:80%; max-width:320px;
        transform:translateX(-100%); transition:transform .3s ease; z-index:1000; box-shadow:2px 0 8px rgba(0,0,0,.2);
      }
      .sidebar.open { transform:translateX(0); }
      #map { grid-row:1/2; height:100vh; }
      .menu-btn { display:inline-flex; align-items:center; gap:8px; }
      .maplibregl-popup-content { width: var(--iw-w-sm); }
      .desk-toggle { display:none !important; }
    }
  </style>

  <!-- Load your config FIRST -->
  <script src="config.js"></script>
</head>
<body>
  <!-- Mobile hamburger -->
  <button class="menu-btn" aria-label="Open filters" aria-controls="sidebar" aria-expanded="false">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
    Filters
  </button>
  <div class="backdrop" aria-hidden="true"></div>

  <div class="app">
    <aside id="sidebar" class="sidebar" role="complementary" aria-label="Filters and locations">
      <header>
        <h1 style="display:none;">Intermountain Health</h1>
        <img id="brand-logo" src="" alt="Intermountain Health" style="max-width:180px; height:auto;" />
        <button class="desk-toggle" aria-label="Hide sidebar" data-state="open" title="Hide sidebar">
          <svg class="icon" width="18" height="18" viewBox="0 0 24 24" fill="none"
               stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
          <span class="label">Hide</span>
        </button>
        <div class="meta" id="summary">Loading placesâ€¦</div>
      </header>

      <div class="controls" id="controls-block">
        <div class="search">
          <input id="search" type="search" placeholder="Search by name, market or keywords" />
        </div>
        <div class="row">
          <button id="btn-nearme" class="icon-btn" title="Use my location" aria-label="Use my location">
            <svg xmlns="http://www.w3.org/2000/svg" class="lucide lucide-crosshair" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="22" y1="12" x2="18" y2="12"></line>
              <line x1="6" y1="12" x2="2" y2="12"></line>
              <line x1="12" y1="6" x2="12" y2="2"></line>
              <line x1="12" y1="22" x2="12" y2="18"></line>
            </svg>
          </button>

          <select id="sort" class="btn" aria-label="Sort">
            <option value="name">Sort: name (Aâ†’Z)</option>
            <option value="distance">Sort: nearest</option>
          </select>

          <button id="btn-reset" class="btn" aria-label="Reset">Reset</button>
        </div>
      </div>

      <div class="filters" id="filters-block">
        <h3>Markets</h3>
        <div id="tag-filters" class="chips"></div>
      </div>

      <div id="list" class="list"></div>
    </aside>

    <div id="map" role="application" aria-label="Map"></div>
  </div>

  <script>
    // ========= Utilities =========
    const cfg = window.APP_CONFIG;
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));
    const $  = (sel) => document.querySelector(sel);
    const norm = (s) => String(s || "").trim().toLowerCase();
    const uniq = (arr)=> Array.from(new Set((arr||[]).filter(Boolean))).sort((a,b)=> a.localeCompare(b));
    const parseList = (val)=> val ? val.split(",").map(s=>s.trim()).filter(Boolean) : [];
    const toRad = d => d * Math.PI / 180;
    function haversine(a, b) {
      const R = 6371000;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
      return 2 * R * Math.asin(Math.sqrt(s));
    }
    function escapeHtml(str){ return String(str||"").replace(/[&<>"']/g, (c)=>({"&":"&amp;","<":"&lt;","&gt;":"&gt;","\"":"&quot;","'":"&#039;"}[c])); }

    // ========= Data (Google Sheets) =========
    async function fetchSheetRows() {
      const { sheetsApiKey, sheetId, sheetRange } = cfg.DATA;
      const url = 'https://sheets.googleapis.com/v4/spreadsheets/' +
                  encodeURIComponent(sheetId) +
                  '/values/' + encodeURIComponent(sheetRange) +
                  '?key=' + encodeURIComponent(sheetsApiKey);
      const res = await fetch(url);
      if (!res.ok) {
        let msg = 'Sheets API error ' + res.status;
        try { const j = await res.json(); if (j.error && j.error.message) msg += ': ' + j.error.message; } catch {}
        throw new Error(msg);
      }
      const json = await res.json();
      const rows = json.values || [];
      if (!rows.length) return [];
      const headers = rows[0].map(h => (h||'').trim());
      return rows.slice(1).map(r => Object.fromEntries(headers.map((h,i)=> [h, r[i] || ""])));
    }

    let uidCounter = 0;
    function normalizeRow(row) {
      const keywords   = parseList(row["Keywords"] || row["Notes"] || "");
      const tagsPretty = parseList(row["Tags"] || "");
      const tagsNorm   = tagsPretty.map(s => s.trim().toLowerCase());
      return {
        _id: uidCounter++,
        name: row["Name"] || "Untitled",
        address: row["Address"] || "",
        lat: parseFloat(row["Latitude"]) || null,
        lng: parseFloat(row["Longitude"]) || null,
        group: row["Group"] || "",
        tags: tagsPretty,
        tagsNorm,
        iconUrl: row["Icon URL"] || "",
        headerImage: row["Header Image URL"] || "",
        moreUrl: row["Learn More URL"] || row["Button Link"] || row["URL"] || "",
        useHtml: String(row["Use HTML"] || "").toLowerCase() === "true",
        keywordsText: keywords.join(", "),
        groupOrder: Number.parseInt(row["Group Order"], 10) || 9999
      };
    }

    // ========= Icons =========
    function normalizeIconValue(v) {
      if (!v) return "";
      const raw = String(v).trim();
      if (/^https?:\/\//i.test(raw)) return raw;
      if (/\.(png|jpe?g|svg|webp)$/i.test(raw)) return raw;
      const token = raw.toLowerCase().replace(/[^a-z]/g, "");
      const tokenMap = {};
      Object.entries(cfg.MAP.iconsByGroup || {}).forEach(([g, file])=>{
        tokenMap[g.toLowerCase().replace(/[^a-z]/g,"")] = file;
      });
      return tokenMap[token] || "";
    }
    function resolveIconSrc(place) {
      const fromCell = normalizeIconValue(place.iconUrl);
      if (fromCell) return fromCell;
      const file = (cfg.MAP.iconsByGroup || {})[place.group] || "";
      return file || "";
    }

    // ========= Coincident point spreading =========
    function metersToDeg(lat, meters) {
      const dLat = meters / 111320;
      const dLng = meters / (111320 * Math.cos(lat * Math.PI / 180));
      return { dLat, dLng };
    }
    function spreadCoincidentPlaces(places, radiusMeters = 20) {
      const buckets = new Map();
      places.forEach((p) => {
        if (!(p.lat && p.lng)) return;
        const key = (p.lat.toFixed(6)) + "|" + (p.lng.toFixed(6));
        if (!buckets.has(key)) buckets.set(key, []);
        buckets.get(key).push(p);
      });
      const result = new Map(); // id -> [lng,lat]
      buckets.forEach((arr) => {
        if (arr.length === 1) {
          const p = arr[0];
          result.set(p._id, [p.lng, p.lat]);
          return;
        }
        const centerLat = arr[0].lat;
        const { dLat, dLng } = metersToDeg(centerLat, radiusMeters);
        const n = arr.length;
        arr.forEach((p, k) => {
          const angle = (2 * Math.PI * k) / n;
          const lat = centerLat + Math.sin(angle) * dLat;
          const lng = p.lng + Math.cos(angle) * dLng;
          result.set(p._id, [lng, lat]);
        });
      });
      return result;
    }

    // ========= Popup HTML =========
    function markerHtml(place) {
      const safeName = escapeHtml(place.name);
      const addrHtml = place.address
        ? '<div class="addr"><a class="addr-link" href="https://www.google.com/maps/search/?api=1&query=' + encodeURIComponent(place.address) + '" target="_blank" rel="noopener">' + escapeHtml(place.address) + '</a></div>'
        : '';
      const group = place.group ? '<div class="group">'+escapeHtml(place.group)+'</div>' : '';
      const tag = (place.tags && place.tags[0]) ? '<div class="tagpill">'+escapeHtml(place.tags[0])+'</div>' : '';
      const headerImg = place.headerImage ? '<div class="hero"><img src="'+place.headerImage+'" alt="'+safeName+'"/>'+tag+'</div>' : '';
      const learnHref = place.moreUrl || ('https://www.google.com/search?q=' + encodeURIComponent(place.name + ' ' + (place.address||'')));
      return [
        '<div class="iw">',
          headerImg,
          '<div class="pad">',
            '<h3>'+safeName+'</h3>',
            group,
            addrHtml,
            '<a class="btn-learn" href="'+learnHref+'" target="_blank" rel="noopener">Learn More</a>',
          '</div>',
        '</div>'
      ].join('');
    }

    // ========= Sidebar state / rendering =========
    const groupState = {};
    let onlyGroup = null;                 // "Show only this group"
    const fadedGroups = new Set();        // groups faded on map & list

    function buildFiltersUI(allPlaces) {
      const allPretty = [].concat.apply([], allPlaces.map(p=> p.tags || []));
      const uniquePretty = uniq(allPretty);
      const items = uniquePretty.map(labelPretty => ({ label: labelPretty, value: norm(labelPretty) }));
      const wrap = $("#tag-filters");
      wrap.innerHTML = items.map(it => `<label class="chip"><input type="checkbox" value="${it.value}" checked /> ${escapeHtml(it.label)}</label>`).join('');
      wrap.addEventListener('change', applyFilters);
    }

    function svgChevron(){ return '<svg class="chev" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>'; }
    function svgEyeIcon(isOff){
      return isOff
        ? '<svg class="eyeoff" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49"></path><path d="M14.084 14.158a3 3 0 0 1-4.242-4.242"></path><path d="M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143"></path><path d="m2 2 20 20"></path></svg>'
        : '<svg class="eye" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"></path><circle cx="12" cy="12" r="3"></circle></svg>';
    }
function svgTarget(){
  return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="7" cy="7" r="6"></circle><line x1="7" y1="1" x2="7" y2="3"></line><line x1="7" y1="13" x2="7" y2="11"></line><line x1="1" y1="7" x2="3" y2="7"></line><line x1="13" y1="7" x2="11" y2="7"></line></svg>';
}
    function renderList(places) {
      const list = $("#list");
      list.innerHTML = "";

      // group
      const grouped = (function groupBy(arr, keyFn){
        const m = new Map();
        (arr||[]).forEach(it=>{
          const k = keyFn(it) || "Other";
          if (!m.has(k)) m.set(k, []);
          m.get(k).push(it);
        });
        return m;
      })(places, p => p.group);

      const orderMap = new Map();
      grouped.forEach((arr, g) => {
        const ord = Math.min(...arr.map(p => p.groupOrder ?? 9999));
        orderMap.set(g, Number.isFinite(ord) ? ord : 9999);
      });

      const groupsSorted = Array.from(grouped.keys()).sort((a,b)=>{
        const oa = orderMap.get(a) ?? 9999, ob = orderMap.get(b) ?? 9999;
        return (oa - ob) || a.localeCompare(b);
      });

      groupsSorted.forEach(g=>{
        if (!groupState[g]) groupState[g] = { collapsed:false, faded:false };

        const section = document.createElement("div");
        section.className = "group-section";

        const head = document.createElement("div");
        head.className = "group-head" + (groupState[g].faded ? " faded" : "");
        head.dataset.group = g;

        const left = document.createElement("div");
        left.className = "left";
        const title = document.createElement("div");
        title.textContent = g || "Other";
        left.appendChild(title);
        if (onlyGroup === g) {
          const onlyPill = document.createElement("span");
          onlyPill.className = "pill";
          onlyPill.textContent = "Only";
          left.appendChild(onlyPill);
        }

        const controls = document.createElement("div");
        controls.className = "controls";

        // fade
        const eyeBtn = document.createElement("button");
        eyeBtn.className = "iconbtn eye-toggle";
        eyeBtn.title = groupState[g].faded ? "Show group at full opacity" : "Fade this group";
        eyeBtn.innerHTML = svgEyeIcon(groupState[g].faded);
        eyeBtn.addEventListener("click", (e)=>{
          e.stopPropagation();
          groupState[g].faded = !groupState[g].faded;
          head.classList.toggle("faded", groupState[g].faded);
          eyeBtn.innerHTML = svgEyeIcon(groupState[g].faded);
          section.querySelectorAll(".card").forEach(el=> el.classList.toggle("faded", groupState[g].faded));
          if (groupState[g].faded) fadedGroups.add(g); else fadedGroups.delete(g);
          updateLayerOpacities();
        });

        // show only this group
        const onlyBtn = document.createElement("button");
        onlyBtn.className = "iconbtn small";
        onlyBtn.title = (onlyGroup === g) ? "Show all groups" : "Show only this group";
        onlyBtn.innerHTML = svgTarget();
        onlyBtn.addEventListener("click", (e)=>{
          e.stopPropagation();
          onlyGroup = (onlyGroup === g) ? null : g;
          applyFilters();     // this will re-render list and map and update pills
        });

        const chevBtn = document.createElement("button");
        chevBtn.className = "iconbtn";
        chevBtn.innerHTML = svgChevron();

        controls.appendChild(eyeBtn);
        controls.appendChild(onlyBtn);
        controls.appendChild(chevBtn);

        head.appendChild(left);
        head.appendChild(controls);
        section.appendChild(head);

        const body = document.createElement("div");
        body.className = "group-body";
        if (groupState[g].collapsed) head.classList.add("collapsed");
        if (groupState[g].faded) body.classList.add("faded");

        head.addEventListener("click", (e)=>{
          if (e.target.closest(".eye-toggle") || e.target === onlyBtn) return;
          groupState[g].collapsed = !groupState[g].collapsed;
          head.classList.toggle("collapsed", groupState[g].collapsed);
        });

        grouped.get(g).forEach(p=>{
          const item = document.createElement("div");
          item.className = "card";
          if (groupState[g].faded) item.classList.add("faded");
          const iconSrc = resolveIconSrc(p);
          const iconEl = iconSrc ? `<img class="pin-img" src="${iconSrc}" alt=""/>` : '';
          item.innerHTML = `${iconEl}<div><h4>${escapeHtml(p.name)}</h4><div class="meta-row">${(p.tags||[]).join(' Â· ')}</div></div>`;

          // Sidebar -> Map fly + popup
          item.addEventListener("click", ()=>{
            const feat = currentFeaturesById.get(p._id);
            if (!feat) return;
            const [lng, lat] = feat.geometry.coordinates;
            if (window.closeDrawer) window.closeDrawer();
            map.flyTo({ center: [lng, lat], zoom: Math.max(map.getZoom(), 15), duration: 600 });
            setTimeout(()=> openPopupAt([lng, lat], markerHtml(p)), 620);
          });

          body.appendChild(item);
        });

        section.appendChild(body);
        list.appendChild(section);
      });

      $("#summary").textContent = places.length + " place" + (places.length===1 ? "" : "s") + " shown";
    }

    // ========= Map & Layers (MapLibre) =========
    let map;
    let allPlaces = [];
    let filteredPlaces = [];
    let userPos = null;

    let loadedIconSet = new Set(); // URLs successfully loaded into style
    let currentFeaturesById = new Map(); // _id => feature
    let activePopup = null;

    function buildGeoJSONFor(places) {
      const coordsMap = spreadCoincidentPlaces(places, 20); // _id => [lng,lat]
      const features = [];
      currentFeaturesById.clear();

      places.forEach((p) => {
        if (!(p.lat && p.lng)) return;
        const coords = coordsMap.get(p._id) || [p.lng, p.lat];
        const iconCandidate = resolveIconSrc(p) || "";
        const iconKey = (iconCandidate && loadedIconSet.has(iconCandidate)) ? iconCandidate : "";
        const feature = {
          type: "Feature",
          geometry: { type: "Point", coordinates: coords },
          properties: {
            _id: p._id,
            name: p.name,
            group: p.group || "Other",
            iconKey,
            tags: (p.tags || []).join(",")
          }
        };
        features.push(feature);
        currentFeaturesById.set(p._id, feature);
      });
      return { type: "FeatureCollection", features };
    }

    async function preloadMarkerImages(map, iconUrls) {
      const unique = Array.from(new Set(iconUrls.filter(Boolean)));
      const results = await Promise.all(unique.map(url => new Promise((resolve) => {
        if (map.hasImage(url)) { loadedIconSet.add(url); return resolve({url, ok:true}); }
        map.loadImage(url, (err, img) => {
          if (!err && img) { map.addImage(url, img); loadedIconSet.add(url); resolve({url, ok:true}); }
          else { resolve({url, ok:false}); }
        });
      })));
      return results;
    }

    function ensureSourceExists() {
      if (map.getSource('places')) return;
      map.addSource('places', {
        type: 'geojson',
        data: { "type":"FeatureCollection", "features":[] },
        cluster: !!cfg.UI?.clustering,
        clusterMaxZoom: 14,
        clusterRadius: 60
      });

      if (cfg.UI?.clustering) {
        map.addLayer({
          id: "clusters",
          type: "circle",
          source: "places",
          filter: ["has", "point_count"],
          paint: {
            "circle-color": "#4A00E2",
            "circle-radius": [
              "step",
              ["get", "point_count"],
              16,
              10, 20,
              25, 24
            ],
            "circle-opacity": 0.9
          }
        });
        map.addLayer({
          id: "cluster-count",
          type: "symbol",
          source: "places",
          filter: ["has", "point_count"],
          layout: {
            "text-field": ["get", "point_count_abbreviated"],
            "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
            "text-size": 12
          },
          paint: { "text-color": "#fff" }
        });
      }

      // unclustered with icon
      map.addLayer({
        id: "unclustered-points",
        type: "symbol",
        source: "places",
        filter: cfg.UI?.clustering ? ["all", ["!", ["has", "point_count"]], ["!=", ["get","iconKey"], ""]]
                                   : ["!=", ["get","iconKey"], ""],
        layout: {
          "icon-image": ["get","iconKey"],
          "icon-size": 0.7,
          "icon-allow-overlap": true
        },
        paint: {
          "icon-opacity": getGroupOpacityExpression()
        }
      });

      // fallback circles
      map.addLayer({
        id: "unclustered-fallback",
        type: "circle",
        source: "places",
        filter: cfg.UI?.clustering ? ["all", ["!", ["has", "point_count"]], ["==", ["get","iconKey"], ""]]
                                   : ["==", ["get","iconKey"], ""],
        paint: {
          "circle-color": "#2E2E2E",
          "circle-radius": 5,
          "circle-stroke-color": "#fff",
          "circle-stroke-width": 1.5,
          "circle-opacity": getGroupOpacityExpression()
        }
      });

      if (cfg.UI?.clustering) {
        map.on('click', 'clusters', (e) => {
          const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
          const clusterId = features[0].properties.cluster_id;
          map.getSource('places').getClusterExpansionZoom(clusterId, (err, zoom) => {
            if (err) return;
            map.easeTo({ center: features[0].geometry.coordinates, zoom });
          });
        });
      }
      ['unclustered-points','unclustered-fallback'].forEach(ly=>{
        map.on('click', ly, (e)=>{
          const f = e.features[0];
          const id = f.properties._id;
          const p = filteredPlaces.find(pp => pp._id == id) || allPlaces.find(pp => pp._id == id);
          if (!p) return;
          openPopupAt(f.geometry.coordinates, markerHtml(p));
        });
        map.on('mouseenter', ly, ()=> map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', ly, ()=> map.getCanvas().style.cursor = '');
      });
    }

    function getGroupOpacityExpression(){
      // ["case", ["in", ["get","group"], ["literal", ["A","B"]]], 0.35, 1]
      const faded = Array.from(fadedGroups);
      return ["case", ["in", ["get","group"], ["literal", faded]], parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade')) || 0.35, 1];
    }
    function updateLayerOpacities(){
      const expr = getGroupOpacityExpression();
      if (map.getLayer("unclustered-points")) map.setPaintProperty("unclustered-points", "icon-opacity", expr);
      if (map.getLayer("unclustered-fallback")) map.setPaintProperty("unclustered-fallback", "circle-opacity", expr);
    }

    function updateSourceData(geojson, fit=true) {
      const src = map.getSource('places');
      if (src) { src.setData(geojson); } else { ensureSourceExists(); map.getSource('places').setData(geojson); }
      if (fit && geojson.features && geojson.features.length) {
        const bounds = new maplibregl.LngLatBounds();
        geojson.features.forEach(f => bounds.extend(f.geometry.coordinates));
        map.fitBounds(bounds, { padding: 60, duration: 400 });
      }
      updateLayerOpacities();
    }

    function openPopupAt(lngLat, html) {
      if (activePopup) { try { activePopup.remove(); } catch {} }
      activePopup = new maplibregl.Popup({ closeOnMove: true, maxWidth: '440px' })
        .setLngLat(lngLat)
        .setHTML(html)
        .addTo(map);
    }

    // ========= Filtering =========
    function applyFilters() {
      const q = $("#search").value.trim().toLowerCase();
      const activeTags = new Set($$("#tag-filters input:checked").map(i=> i.value));

      filteredPlaces = allPlaces.filter(p=>{
        let ok = true;
        if (onlyGroup) {
          ok = (p.group === onlyGroup);
        }
        if (ok && activeTags.size > 0) {
          const ptags = p.tagsNorm || [];
          ok = ptags.some(t => activeTags.has(t));
        }
        if (ok && q) {
          const hay = (p.name + " " + p.group + " " + (p.tags||[]).join(" ") + " " + p.keywordsText).toLowerCase();
          if (!hay.includes(q)) ok = false;
        }
        return ok;
      });

      if (userPos && $("#sort").value === 'distance') {
        filteredPlaces.forEach(p => p._distanceM = haversine(userPos, {lat: p.lat, lng: p.lng}));
        filteredPlaces.sort((a,b)=> a._distanceM - b._distanceM);
      } else {
        filteredPlaces.sort((a,b)=> a.name.localeCompare(b.name));
      }

      renderList(filteredPlaces);
      const geo = buildGeoJSONFor(filteredPlaces);
      updateSourceData(geo, true);
      $("#summary").textContent = filteredPlaces.length + " place" + (filteredPlaces.length===1 ? "" : "s") + " shown";
    }

    // ========= Sidebar show/hide (desktop) =========
    (function sidebarToggle(){
      let desktopSidebarCollapsed = false;
      const appEl = document.querySelector('.app');
      const deskToggleBtn = document.querySelector('.desk-toggle');
      const headerEl = document.querySelector('.sidebar header');
      function dock(){ headerEl.appendChild(deskToggleBtn); deskToggleBtn.classList.remove('desk-toggle-floating'); deskToggleBtn.querySelector('.icon')?.classList.remove('flipped'); }
      function floatBtn(){ document.body.appendChild(deskToggleBtn); deskToggleBtn.classList.add('desk-toggle-floating'); deskToggleBtn.querySelector('.icon')?.classList.add('flipped'); }
      function setCollapsed(v){
        desktopSidebarCollapsed = !!v;
        appEl.classList.toggle('sidebar-collapsed', desktopSidebarCollapsed);
        if (desktopSidebarCollapsed) floatBtn(); else dock();
        deskToggleBtn.setAttribute('aria-label', desktopSidebarCollapsed ? 'Show sidebar' : 'Hide sidebar');
        deskToggleBtn.title = desktopSidebarCollapsed ? 'Show sidebar' : 'Hide sidebar';
        deskToggleBtn.dataset.state = desktopSidebarCollapsed ? 'closed' : 'open';
        const label = deskToggleBtn.querySelector('.label'); if (label) label.textContent = desktopSidebarCollapsed ? 'Show' : 'Hide';
      }
      dock();
      deskToggleBtn.addEventListener('click', ()=>{
        const isDesktop = window.matchMedia('(min-width: 769px)').matches;
        if (!isDesktop) return;
        setCollapsed(!desktopSidebarCollapsed);
      });
      window.addEventListener('resize', ()=>{
        const isDesktop = window.matchMedia('(min-width: 769px)').matches;
        if (!isDesktop) { if (desktopSidebarCollapsed) setCollapsed(false); }
        else { if (!desktopSidebarCollapsed) dock(); }
      });
    })();

    // ========= Drawer (mobile) =========
    (function drawer(){
      const menuBtn = document.querySelector('.menu-btn');
      const sidebarEl = document.getElementById('sidebar');
      const backdrop = document.querySelector('.backdrop');
      function open(){ sidebarEl.classList.add('open'); backdrop.classList.add('show'); menuBtn.setAttribute('aria-expanded','true'); document.body.style.overflow='hidden'; }
      function close(){ sidebarEl.classList.remove('open'); backdrop.classList.remove('show'); menuBtn.setAttribute('aria-expanded','false'); document.body.style.overflow=''; }
      menuBtn.addEventListener('click', ()=> sidebarEl.classList.contains('open') ? close() : open());
      backdrop.addEventListener('click', close);
      window.closeDrawer = close;
    })();

    // ========= Geolocation =========
    function getUserLocation(){
      return new Promise((resolve, reject)=>{
        if (!navigator.geolocation) return reject(new Error('No geolocation'));
        navigator.geolocation.getCurrentPosition(
          (pos)=> resolve({ lat: pos.coords.latitude, lng: pos.coords.longitude }),
          (err)=> reject(err),
          { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
      });
    }

    // ========= Init & Reset =========
    async function resetAll() {
      // Clear UI controls
      $$("#tag-filters input[type=checkbox]").forEach(i=> i.checked = true);
      $('#search').value = '';
      $('#sort').value = 'name';
      onlyGroup = null;
      fadedGroups.clear();
      Object.keys(groupState).forEach(k=> groupState[k] = { collapsed:false, faded:false });

      // Close popup
      if (activePopup) { try { activePopup.remove(); } catch {} activePopup = null; }

      // Restore full dataset view
      filteredPlaces = [...allPlaces];
      renderList(filteredPlaces);
      const geo = buildGeoJSONFor(filteredPlaces);
      updateSourceData(geo, true);
      $("#summary").textContent = filteredPlaces.length + " place" + (filteredPlaces.length===1 ? "" : "s") + " shown";
    }

    async function init() {
      try {
        // Branding & optional hides
        const logoPath = (cfg.MAP && cfg.MAP.logo) ? cfg.MAP.logo : '';
        if (logoPath) document.getElementById('brand-logo').src = logoPath;
        if (cfg.UI?.hideControls) document.getElementById('controls-block').style.display = 'none';
        if (cfg.UI?.hideFilters) document.getElementById('filters-block').style.display = 'none';

        // Data
        const rows = await fetchSheetRows();
        allPlaces = rows.map(normalizeRow).filter(p => p.lat && p.lng);
        filteredPlaces = [...allPlaces];

        // Map
        const styleUrl = (cfg.MAP && cfg.MAP.style) ? cfg.MAP.style : 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json';
        map = new maplibregl.Map({
          container: 'map',
          style: styleUrl,
          center: [cfg.MAP.center.lng, cfg.MAP.center.lat],
          zoom: cfg.MAP.zoom,
          minZoom: cfg.MAP.minZoom ?? 3,
          attributionControl: true
        });
        map.addControl(new maplibregl.NavigationControl({ showCompass: false }), 'top-right');

        map.on('load', async ()=>{
          // Preload icons (from ALL places)
          const allIconUrls = Array.from(new Set(allPlaces.map(p => resolveIconSrc(p)).filter(Boolean)));
          await preloadMarkerImages(map, allIconUrls);

          // Source/layers and initial data
          ensureSourceExists();
          const initialGeo = buildGeoJSONFor(filteredPlaces);
          updateSourceData(initialGeo, true);

          // UI
          buildFiltersUI(allPlaces);
          renderList(filteredPlaces);
          $("#summary").textContent = filteredPlaces.length + " place" + (filteredPlaces.length===1 ? "" : "s") + " shown";
        });

        // Wire controls
        $('#search').addEventListener('input', applyFilters);
        $('#sort').addEventListener('change', applyFilters);
        $('#btn-reset').addEventListener('click', resetAll);

        $('#btn-nearme').addEventListener('click', async ()=>{
          try {
            const pos = await getUserLocation();
            userPos = pos;
            new maplibregl.Marker({ color: '#4A00E2' }).setLngLat([pos.lng, pos.lat]).addTo(map);
            map.flyTo({ center: [pos.lng, pos.lat], zoom: Math.max(map.getZoom(), 12) });
            $('#sort').value = 'distance';
            applyFilters();
          } catch {
            alert('Location permission was denied or unavailable.');
          }
        });

      } catch (err) {
        console.error(err);
        alert('Failed to initialize: ' + err.message);
      }
    }

    init();
  </script>
</body>
</html>
