<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Intermountain Health – Map (MapLibre + Sheets + Clusters)</title>
  <meta name="description" content="MapLibre GL JS + Google Sheets data + clustering + custom icons + Freshpaint-ready." />
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;600;700&family=Source+Sans+3:wght@400;600&display=swap" rel="stylesheet">

  <!-- MapLibre GL -->
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

  <!-- Config -->
  <script src="config.js"></script>

  <style>
    :root {
      --sidebar-w: 380px;
      --accent: #4A00E2;
      --dark: #110057;
      --muted: #6b7280;
      --chip: #F7F5F9;
      --fade: 0.35;
      --iw-w: 320px;
      --iw-w-sm: 300px;
    }

    html, body { height: 100%; margin: 0; color: var(--dark); font-family: 'Source Sans 3', Arial, sans-serif; }
    h1, h2, h3, h4, .btn, .chip { font-family: 'Inter', Arial, sans-serif; }

    .app { height: 100vh; display: grid; grid-template-columns: var(--sidebar-w) 1fr; }
    .sidebar { height: 100%; overflow: hidden; border-right: 1px solid #e5e7eb; display: flex; flex-direction: column; background: #fff; }
    .sidebar header { padding: 16px 16px 8px; border-bottom: 1px solid #e5e7eb; position: relative; }
    .sidebar h1 { margin: 0 0 6px; font-size: 20px; font-weight: 700; }

    .controls { padding: 12px 16px; border-bottom: 1px solid #e5e7eb; gap: 8px; display: grid; grid-template-columns: 1fr; background: #fff; }
    .row { display: flex; gap: 8px; align-items: center; }
    .row > * { flex: 1; }
    .search input { width:100%; padding: 10px 12px; border: 1px solid #d1d5db; border-radius: 10px; font-size: 14px; }
    .btn { appearance: none; border: 1px solid #d1d5db; background: #fff; border-radius: 10px; padding: 8px 10px; font-size: 13px; cursor: pointer; }

    .filters { padding: 10px 16px; overflow: auto; border-bottom: 1px solid #e5e7eb; max-height: 30%; background: #fff; }
    .filters h3 { margin: 10px 0 8px; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: .06em; }
    .chips { display: flex; flex-wrap: wrap; gap: 6px; }
    .chip { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--chip); border: 1px solid #e5e7eb; border-radius: 999px; font-size: 12px; cursor: pointer; user-select: none; }

    .list { overflow: auto; flex: 1; background: #fff; }

    .group-section { border-top: 1px solid #eee; }
    .group-head {
      display:flex; align-items:center; justify-content:space-between;
      padding: 10px 12px 10px 16px; font-size: 13px; color:#374151; font-weight:600;
      text-transform: uppercase; letter-spacing: .04em; background:#fafafa;
      position: sticky; top: 0; z-index: 1;
      border-bottom:1px solid #f0f0f0;
    }
    .group-head .title { display:flex; align-items:center; gap:10px; }
    .group-head .controls { display:flex; align-items:center; gap:10px; }
    .iconbtn { appearance:none; border:none; background:transparent; padding:4px; cursor:pointer; color:#374151; display:inline-flex; align-items:center; justify-content:center; border-radius:6px; }
    .iconbtn:hover { background:#efefef; }
    .chev { transition: transform .18s ease; }
    .collapsed .chev { transform: rotate(90deg); }
    .faded { opacity: var(--fade); }

    .group-body { display:block; }
    .collapsed + .group-body { display:none; }

    .card { border-bottom: 1px solid #f3f4f6; padding: 12px 16px; cursor: pointer; display:flex; align-items:center; gap:10px; }
    .card:hover { background: #f9fafb; }
    .card h4 { margin: 0 0 2px; font-size: 15px; }
    .meta { color: var(--muted); font-size: 12px; }
    .pin-img { width: 20px; height: 20px; flex:0 0 20px; object-fit: contain; }

    #map { height: 100%; width: 100%; }

    /* MapLibre popup */
    .maplibregl-popup { max-width: var(--iw-w); }
    .maplibregl-popup-content {
      padding: 0;
      width: var(--iw-w);
      max-width: 90vw;
      font-family: 'Source Sans 3', Arial, sans-serif;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      overflow: hidden;
    }
    .iw .hero { position: relative; width: 100%; height: 150px; overflow: hidden; }
    .iw .hero img { display:block; width:100%; height:100%; object-fit:cover; object-position:center; }
    .iw .tagpill { position:absolute; top:10px; left:10px; background:#ffffff; color:#111827; font-size:12px; padding:4px 10px; border-radius:999px; border:1px solid #e5e7eb; }
    .iw .pad { padding: 12px 14px 14px; }
    .iw h3 { margin:10px 0 4px; font-size:18px; font-weight:700; }
    .iw .group { color:#374151; font-size:13px; margin-bottom:8px; }
    .iw .addr { margin-bottom:8px; }
    .iw .addr-link { font-size: 15px; font-weight: 600; color: #110057; text-decoration: underline; }
    .iw .addr-link:hover { text-decoration: none; }
    .iw .btn-learn {
      display:block; width:100%; box-sizing:border-box; text-align:center;
      padding:12px 14px; background:#110057; color:#fff; border-radius:10px;
      text-decoration:none; font-family:'Inter', Arial, sans-serif; font-weight:600;
      margin-top:10px; white-space:normal; overflow:hidden; text-overflow:ellipsis;
    }

    /* Icon-only controls */
    .icon-btn { border: none; background: none; padding: 6px; border-radius: 6px; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; color: var(--dark); }
    .icon-btn:hover { background: #f3f4f6; }
    .icon-btn svg { width: 18px; height: 18px; }

    /* Mobile drawer */
    .menu-btn {
      display: none; position: absolute; top: 10px; left: 10px; z-index: 3000;
      background:#110057; color:#fff; border:none; padding:10px 12px; border-radius:6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .menu-btn:focus { outline: 2px solid #4A00E2; outline-offset: 2px; }
    .backdrop { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.4); z-index: 2000; }
    .backdrop.show { display:block; }

    /* Desktop sidebar toggle */
    @media (min-width: 769px) {
      .desk-toggle { display:inline-flex; }
      body.embed.embed-chrome-off .desk-toggle { display:none !important; }
    }
    .desk-toggle {
      position: absolute; top: 8px; right: 12px; z-index: 3000;
      background: #110057; color: #fff; border: none; padding: 8px 10px; border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,.2); align-items: center; gap: 6px; cursor: pointer; display: inline-flex;
    }
    .desk-toggle .icon { transition: transform .2s ease; }
    .desk-toggle-floating { position: fixed !important; top: 12px !important; left: 12px !important; right: auto !important; z-index: 3000 !important; display: inline-flex !important; }
    .desk-toggle .icon.flipped { transform: rotate(180deg); }
    .app .sidebar{ transition: transform .3s ease; }
    .app.sidebar-collapsed{ grid-template-columns: 0 1fr !important; }
    .app.sidebar-collapsed .sidebar{ transform: translateX(-100%); }
    .app.sidebar-collapsed .desk-toggle{ position: fixed !important; top: 12px !important; left: 12px !important; right: auto !important; }
    .app.sidebar-collapsed .desk-toggle .icon{ transform: rotate(180deg); }

    /* Responsive */
    @media (max-width: 768px) {
      .app { grid-template-columns: 1fr; grid-template-rows: 1fr; }
      .sidebar {
        position: fixed; top: 0; left: 0; height: 100%; width: 80%; max-width: 320px;
        transform: translateX(-100%); transition: transform .3s ease; z-index: 2500; box-shadow: 2px 0 8px rgba(0,0,0,0.2);
      }
      .sidebar.open { transform: translateX(0); }
      #map { grid-row: 1 / 2; height: 100vh; }
      .menu-btn { display: inline-flex; align-items: center; gap: 8px; }
      .maplibregl-popup, .maplibregl-popup-content { max-width: var(--iw-w-sm); width: var(--iw-w-sm); }
      .desk-toggle { display: none !important; }
    }

    /* EMBED MODE */
    html.embed, body.embed { height: 100%; margin: 0; padding: 0; }
    body.embed .app { height: 100vh; }
    body.embed.embed-chrome-off .sidebar, body.embed.embed-chrome-off .menu-btn, body.embed.embed-chrome-off .backdrop, body.embed.embed-chrome-off .desk-toggle { display: none !important; }
    body.embed.embed-chrome-off .app { display: block !important; width: 100% !important; height: 100vh !important; margin: 0; padding: 0; }
    body.embed.embed-chrome-off #map { position: absolute !important; inset: 0; width: 100% !important; height: 100% !important; }
  </style>

  <!-- EMBED MODE CLASS TOGGLER -->
  <script>
    (function () {
      try {
        const params = new URLSearchParams(location.search);
        if (params.get('embed') === '1') {
          document.documentElement.classList.add('embed');
          const apply = () => {
            document.body && document.body.classList.add('embed');
            if (params.get('chrome') === '0') {
              document.body && document.body.classList.add('embed-chrome-off');
            }
          };
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', apply, { once: true });
          } else {
            apply();
          }
        }
      } catch (_) {}
    })();
  </script>
</head>
<body>
  <!-- Mobile hamburger -->
  <button class="menu-btn" aria-label="Open filters" aria-controls="sidebar" aria-expanded="false">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
    Filters
  </button>
  <div class="backdrop" aria-hidden="true"></div>

  <div class="app">
    <aside id="sidebar" class="sidebar" role="complementary" aria-label="Filters and locations">
      <header>
        <h1 style="display:none;">Intermountain Health</h1>
        <img id="brand-logo" src="" alt="Intermountain Health" style="max-width:180px; height:auto;" />
        <button class="desk-toggle" aria-label="Hide sidebar" data-state="open" title="Hide sidebar">
          <svg class="icon" width="18" height="18" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
          <span class="label">Hide</span>
        </button>
        <div class="meta" id="summary">Loading places…</div>
      </header>

      <div class="controls" id="controls">
        <div class="search">
          <input id="search" type="search" placeholder="Search by name, market or keywords" />
        </div>
        <div class="row">
          <button id="btn-nearme" class="icon-btn" title="Use my location" aria-label="Use my location">
            <svg xmlns="http://www.w3.org/2000/svg" class="lucide lucide-crosshair" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="22" y1="12" x2="18" y2="12"></line>
              <line x1="6" y1="12" x2="2" y2="12"></line>
              <line x1="12" y1="6" x2="12" y2="2"></line>
              <line x1="12" y1="22" x2="12" y2="18"></line>
            </svg>
          </button>

          <select id="sort" class="btn" aria-label="Sort">
            <option value="name">Sort: name (A→Z)</option>
            <option value="distance">Sort: nearest</option>
          </select>

          <button id="btn-reset" class="icon-btn" title="Clear filters" aria-label="Clear filters">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
                 fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <path d="M21 12a9 9 0 1 1-2.64-6.36"/>
              <path d="M21 3v6h-6"/>
            </svg>
          </button>
        </div>
      </div>

      <div class="filters" id="filters">
        <h3>Markets</h3>
        <div id="tag-filters" class="chips"></div>
      </div>

      <div id="list" class="list"></div>
    </aside>

    <div id="map" role="application" aria-label="Map"></div>
  </div>

  <script>
    const APP = window.APP_CONFIG || {};
    if (!APP.DATA) { alert('config.js not loaded (APP_CONFIG).'); }
    (function(){ const logo = document.getElementById('brand-logo'); if (logo && APP.MAP && APP.MAP.logo) logo.src = APP.MAP.logo; })();

    // Freshpaint (no-op until envId present)
    let fpReady = false;
    (function initFreshpaint(){
      try {
        const f = APP.FRESHPAINT || {};
        if (!f.enabled || !f.envId) return;
        (function(){var fp=window.freshpaint=window.freshpaint||[]; if(!fp.initialize){
          if(fp.invoked){if(window.console&&console.error){console.error("Freshpaint snippet included twice.")} return;}
          fp.invoked=!0; fp.methods=["track","identify","group","page","alias"];
          fp.factory=function(n){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(n);fp.push(e);return fp}};
          for(var i=0;i<fp.methods.length;i++){var key=fp.methods[i];fp[key]=fp.factory(key)}
          fp.load=function(e){var t=document.createElement("script");t.type="text/javascript";t.async=!0;
            t.src="https://cdn.freshpaint.io/static/js/freshpaint.js";
            var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n); fp._loadOptions={env:e};};
        }})(); window.freshpaint.load(f.envId); fpReady = true;
      } catch(e){}
    })();
    function trackFP(name, props){ if (fpReady && window.freshpaint?.track) try{ window.freshpaint.track(name, props||{});}catch(e){} }

    // Sidebar toggle
    let desktopSidebarCollapsed = false;
    const appEl = document.querySelector('.app');
    const deskToggleBtn = document.querySelector('.desk-toggle');
    const headerEl = document.querySelector('.sidebar header');
    function refreshMapSize(){ if (window._map) window._map.resize(); }
    function dockToggleToHeader(){ if (!deskToggleBtn || !headerEl) return; headerEl.appendChild(deskToggleBtn); deskToggleBtn.classList.remove('desk-toggle-floating'); deskToggleBtn.querySelector('.icon')?.classList.remove('flipped'); }
    function floatToggleToViewport(){ if (!deskToggleBtn) return; document.body.appendChild(deskToggleBtn); deskToggleBtn.classList.add('desk-toggle-floating'); deskToggleBtn.querySelector('.icon')?.classList.add('flipped'); }
    function setDesktopSidebar(collapsed) {
      desktopSidebarCollapsed = !!collapsed;
      appEl.classList.toggle('sidebar-collapsed', desktopSidebarCollapsed);
      if (desktopSidebarCollapsed) { floatToggleToViewport(); } else { dockToggleToHeader(); }
      setTimeout(refreshMapSize, 320);
      trackFP("sidebar_toggle", { visible: !desktopSidebarCollapsed });
    }
    dockToggleToHeader();
    if (deskToggleBtn) deskToggleBtn.addEventListener('click',()=>{ if (!window.matchMedia('(min-width: 769px)').matches) return; setDesktopSidebar(!desktopSidebarCollapsed); });
    window.addEventListener('resize', ()=>{ if (!window.matchMedia('(min-width: 769px)').matches) { if (desktopSidebarCollapsed) setDesktopSidebar(false);} else { if (!desktopSidebarCollapsed) dockToggleToHeader(); refreshMapSize(); } });

    // Helpers
    const $  = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));
    const norm = (s) => String(s || "").trim().toLowerCase();
    const uniq = (arr)=> Array.from(new Set((arr||[]).filter(Boolean)));
    const parseList = (val)=> val ? val.split(",").map((s)=> s.trim()).filter(Boolean) : [];
    function escapeHtml(str){ return String(str||"").replace(/[&<>"']/g, (c)=>({"&":"&amp;","<":"&lt;","&gt;":"&gt;","\"":"&quot;","'":"&#039;"}[c])); }

    // Icons
    function normalizeIconValue(v) {
      if (!v) return "";
      const raw = String(v).trim();
      if (/^https?:\/\//i.test(raw)) return raw;
      if (/\.(png|jpe?g|svg|webp)$/i.test(raw)) return raw;
      const groupMap = APP.MAP?.iconsByGroup || {};
      return groupMap[raw] || ""; // allow “Cobalt” etc.
    }
    function resolveIconSrc(place) {
      const fromCell = normalizeIconValue(place.iconUrl);
      if (fromCell) return fromCell;
      const byGroup = APP.MAP?.iconsByGroup ? APP.MAP.iconsByGroup[place.group] : null;
      return byGroup || "";
    }

    // Haversine + stagger coincident points
    function haversine(a, b) {
      const R = 6371000, toRad=(d)=>d*Math.PI/180;
      const dLat = toRad(b.lat - a.lat), dLng = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
      return 2 * R * Math.asin(Math.sqrt(s));
    }
    function metersToDeg(lat, meters) { const dLat = meters / 111320; const dLng = meters / (111320 * Math.cos(lat * Math.PI / 180)); return { dLat, dLng }; }
    function spreadCoincidentPlaces(places, radiusMeters = 20) {
      const buckets = new Map();
      places.forEach((p, idx) => {
        const key = (p.lat?.toFixed(6) || "0") + "|" + (p.lng?.toFixed(6) || "0");
        if (!buckets.has(key)) buckets.set(key, []);
        buckets.get(key).push(idx);
      });
      const adjusted = new Array(places.length);
      buckets.forEach((indices) => {
        if (indices.length === 1) { const i = indices[0]; adjusted[i] = { lat: places[i].lat, lng: places[i].lng }; return; }
        const centerLat = places[indices[0]].lat;
        const { dLat, dLng } = metersToDeg(centerLat, radiusMeters);
        const n = indices.length;
        indices.forEach((i, k) => {
          const angle = (2 * Math.PI * k) / n;
          adjusted[i] = { lat: centerLat + Math.sin(angle) * dLat, lng: places[i].lng + Math.cos(angle) * dLng };
        });
      });
      return adjusted.map((pos, i) => pos || { lat: places[i].lat, lng: places[i].lng });
    }

    // Popup HTML
    function markerHtml(place) {
      const safeName = escapeHtml(place.name);
      const addr = place.address
        ? '<div class="addr"><a class="addr-link" href="https://www.google.com/maps/search/?api=1&query=' + encodeURIComponent(place.address) + '" target="_blank" rel="noopener">' + escapeHtml(place.address) + '</a></div>'
        : '';
      const group = place.group ? '<div class="group">'+escapeHtml(place.group)+'</div>' : '';
      const tag = (place.tags && place.tags[0]) ? '<div class="tagpill">'+escapeHtml(place.tags[0])+'</div>' : '';
      const headerImg = place.headerImage ? '<div class="hero"><img src="'+place.headerImage+'" alt="'+safeName+'"/>'+tag+'</div>' : '';
      const learnHref = place.moreUrl || ('https://www.google.com/search?q=' + encodeURIComponent(place.name + ' ' + (place.address||'')));
      return ['<div class="iw">', headerImg, '<div class="pad">', '<h3>'+safeName+'</h3>', group, addr, '<a class="btn-learn" href="'+learnHref+'" target="_blank" rel="noopener">Learn More</a>', '</div>', '</div>'].join('');
    }

    // Data (Sheets)
    async function fetchSheetRows() {
      const key = APP.DATA?.sheetsApiKey;
      const id  = APP.DATA?.sheetId;
      const rng = APP.DATA?.sheetRange || 'Sheet1!A:Z';
      if (!key || !id) throw new Error('Missing Sheet config or API key.');
      const url = 'https://sheets.googleapis.com/v4/spreadsheets/'+id+'/values/'+encodeURIComponent(rng)+'?key='+key;
      const res = await fetch(url);
      if (!res.ok) throw new Error('Sheets API error '+res.status);
      const json = await res.json();
      const rows = json.values || [];
      if (!rows.length) return [];
      const headers = rows[0].map((h)=> (h||'').trim());
      return rows.slice(1).map((r)=> Object.fromEntries(headers.map((h,i)=> [h, r[i] || ""])));
    }
    function normalizeRow(row) {
      const keywords   = parseList(row["Keywords"] || row["Notes"] || "");
      const tagsPretty = parseList(row["Tags"] || "");
      const tagsNorm   = tagsPretty.map((s)=> String(s).trim().toLowerCase());
      return {
        name: row["Name"] || "Untitled",
        address: row["Address"] || "",
        lat: parseFloat(row["Latitude"]) || null,
        lng: parseFloat(row["Longitude"]) || null,
        group: row["Group"] || "",
        tags: tagsPretty,
        tagsNorm,
        iconUrl: row["Icon URL"] || "",
        headerImage: row["Header Image URL"] || "",
        moreUrl: row["Learn More URL"] || row["URL"] || "",
        useHtml: String(row["Use HTML"] || "").toLowerCase() === "true",
        keywordsText: keywords.join(", "),
        groupOrder: Number.parseInt(row["Group Order"], 10) || 9999
      };
    }
    function groupBy(arr, keyFn) {
      const m = new Map();
      (arr||[]).forEach((it)=>{ const k = keyFn(it) || "Other"; if (!m.has(k)) m.set(k, []); m.get(k).push(it); });
      return m;
    }

    // Map & layers
    let map, allPlaces = [], userPos = null, popup = null, onlyGroup = null;
    const groupState = {};
    let placesSourceId = 'places-src', unclusteredLayerId = 'places-unclustered', clustersLayerId = 'clusters', clusterCountLayerId = 'cluster-count';

    function initMap() {
      const styleUrl = (APP.MAP && APP.MAP.style) || "https://basemaps.cartocdn.com/gl/positron-gl-style/style.json";
      map = new maplibregl.Map({
        container: 'map',
        style: styleUrl,
        center: (APP.MAP && APP.MAP.center) || {lat: 37.0953, lng: -113.5786},
        zoom: (APP.MAP && APP.MAP.zoom) || 9,
        attributionControl: true
      });
      window._map = map;
      map.addControl(new maplibregl.NavigationControl({ visualizePitch: false }), 'top-right');
      map.on('load', () => trackFP('map_loaded', { provider: 'maplibre' }));
    }

    function uniqueIconsFor(places) {
      const set = new Set();
      places.forEach(p => { const src = resolveIconSrc(p); if (src) set.add(src); });
      return Array.from(set);
    }
    function loadImages(map, urls) {
      return Promise.all(urls.map(url => new Promise((resolve) => {
        if (map.hasImage(url)) return resolve();
        map.loadImage(url, (err, img) => {
          if (err || !img) { // fallback tiny pin
            const c = new OffscreenCanvas(40,40), ctx=c.getContext('2d'); ctx.fillStyle='#4A00E2'; ctx.beginPath(); ctx.arc(20,20,8,0,Math.PI*2); ctx.fill();
            map.addImage(url, c.transferToImageBitmap ? c.transferToImageBitmap() : img, { pixelRatio: 2 });
            return resolve();
          }
          map.addImage(url, img, { pixelRatio: 2 });
          resolve();
        });
      })));
    }

    function toGeoJSON(places, adjustedPositions) {
      return {
        type: 'FeatureCollection',
        features: places.map((p, i) => ({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [ (adjustedPositions[i]||p).lng, (adjustedPositions[i]||p).lat ] },
          properties: {
            idx: i,
            name: p.name,
            address: p.address || '',
            group: p.group || '',
            tags: (p.tags||[]).join(', '),
            icon: resolveIconSrc(p) || 'default-pin',
            html: markerHtml(p),
            faded: !!(groupState[p.group]?.faded)
          }
        }))
      };
    }

    function addOrUpdateSourceAndLayers(geojson) {
      if (map.getSource(placesSourceId)) {
        map.getSource(placesSourceId).setData(geojson);
        return;
      }
      map.addSource(placesSourceId, {
        type: 'geojson',
        data: geojson,
        cluster: true,
        clusterRadius: 52,
        clusterMaxZoom: 14
      });

      // Cluster bubbles
      map.addLayer({
        id: clustersLayerId,
        type: 'circle',
        source: placesSourceId,
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': '#4A00E2',
          'circle-radius': ['interpolate', ['linear'], ['get', 'point_count'], 2, 18, 30, 26, 100, 34],
          'circle-opacity': 0.9
        }
      });
      // Cluster counts
      map.addLayer({
        id: clusterCountLayerId,
        type: 'symbol',
        source: placesSourceId,
        filter: ['has', 'point_count'],
        layout: {
          'text-field': ['get', 'point_count_abbreviated'],
          'text-size': 12,
          'text-font': ['Open Sans Bold','Arial Unicode MS Bold']
        },
        paint: { 'text-color': '#FFFFFF' }
      });
      // Unclustered points with per-feature icons
      map.addLayer({
        id: unclusteredLayerId,
        type: 'symbol',
        source: placesSourceId,
        filter: ['!', ['has', 'point_count']],
        layout: {
          'icon-image': ['get', 'icon'],
          'icon-size': 0.9,
          'icon-anchor': 'bottom',
          'icon-allow-overlap': true
        },
        paint: {
          'icon-opacity': [
            'case',
            ['boolean', ['get','faded'], false],
            parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade')) || 0.35,
            1
          ]
        }
      });

      // Click cluster: zoom in
      map.on('click', clustersLayerId, (e) => {
        const features = map.queryRenderedFeatures(e.point, { layers: [clustersLayerId] });
        const clusterId = features[0].properties.cluster_id;
        const source = map.getSource(placesSourceId);
        source.getClusterExpansionZoom(clusterId, (err, zoom) => {
          if (err) return;
          map.easeTo({ center: features[0].geometry.coordinates, zoom });
        });
      });

      // Click point: open popup
      map.on('click', unclusteredLayerId, (e) => {
        const f = e.features && e.features[0]; if (!f) return;
        const coords = f.geometry.coordinates.slice();
        const html = f.properties.html;
        if (popup) popup.remove();
        popup = new maplibregl.Popup({ closeOnClick: true, maxWidth: getComputedStyle(document.documentElement).getPropertyValue('--iw-w') || '320px' })
          .setLngLat(coords)
          .setHTML(html)
          .addTo(map);
        trackFP('marker_opened', { group: f.properties.group || null, hasAddress: !!f.properties.address });
      });

      // Cursor hints
      map.on('mouseenter', clustersLayerId, () => map.getCanvas().style.cursor = 'pointer');
      map.on('mouseleave', clustersLayerId, () => map.getCanvas().style.cursor = '');
      map.on('mouseenter', unclusteredLayerId, () => map.getCanvas().style.cursor = 'pointer');
      map.on('mouseleave', unclusteredLayerId, () => map.getCanvas().style.cursor = '');
    }

    function fitToGeoJSON(geojson) {
      if (!geojson.features.length) return;
      if (geojson.features.length === 1) {
        const c = geojson.features[0].geometry.coordinates;
        map.easeTo({ center: c, zoom: Math.max(map.getZoom(), 15), duration: 500 });
        return;
      }
      const b = new maplibregl.LngLatBounds();
      geojson.features.forEach(f => b.extend(f.geometry.coordinates));
      map.fitBounds(b, { padding: 60, duration: 500 });
    }

    // UI: filters/search/list
    function buildFiltersUI(places) {
      const allPretty = [].concat.apply([], places.map((p)=> p.tags || []));
      const uniquePretty = uniq(allPretty).sort((a,b)=> a.localeCompare(b));
      const items = uniquePretty.map((labelPretty)=> ({ label: labelPretty, value: norm(labelPretty) }));
      const tagWrap = $("#tag-filters");
      tagWrap.innerHTML = items.map((it)=> '<label class="chip"><input type="checkbox" value="'+it.value+'" checked /> '+((it.label||'')||'').replace(/</g,'&lt;')+'</label>').join('');
      tagWrap.addEventListener('change', ()=> applyFilters(true));
    }

    const svgChevron = () => '<svg class="chev" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>';
    const svgEye     = () => '<svg class="eye" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"></path><circle cx="12" cy="12" r="3"></circle></svg>';
    const svgEyeOff  = () => '<svg class="eyeoff" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49"></path><path d="M14.084 14.158a3 3 0 0 1-4.242-4.242"></path><path d="M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143"></path><path d="m2 2 20 20"></path></svg>';
    const svgTargetSmall = () => '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="8" cy="8" r="6"></circle><line x1="16" y1="8" x2="13" y2="8"></line><line x1="3" y1="8" x2="0" y2="8"></line><line x1="8" y1="3" x2="8" y2="0"></line><line x1="8" y1="16" x2="8" y2="13"></line></svg>';

    function renderList(places) {
      const list = $("#list"); list.innerHTML = "";
      const grouped = groupBy(places, (p)=> p.group);
      const orderMap = new Map();
      grouped.forEach((arr, g) => { const ord = Math.min(...arr.map(p => p.groupOrder ?? 9999)); orderMap.set(g, Number.isFinite(ord) ? ord : 9999); });
      const groupsSorted = Array.from(grouped.keys()).sort((a,b)=> (orderMap.get(a)??9999) - (orderMap.get(b)??9999) || a.localeCompare(b));

      groupsSorted.forEach((g)=>{
        if (!groupState[g]) groupState[g] = { collapsed: false, faded: false };
        const section = document.createElement("div"); section.className = "group-section";
        const head = document.createElement("div"); head.className = "group-head" + (groupState[g].faded ? " faded" : ""); head.dataset.group = g;
        const titleWrap = document.createElement("div"); titleWrap.className = "title"; titleWrap.textContent = g || "Other";
        const controls = document.createElement("div"); controls.className = "controls";

        const onlyBtn = document.createElement("button"); onlyBtn.className = "iconbtn"; onlyBtn.title = "Show only this group"; onlyBtn.innerHTML = svgTargetSmall();
        onlyBtn.addEventListener("click", (e)=>{ e.stopPropagation(); onlyGroup = (onlyGroup === g) ? null : g; applyFilters(true); trackFP("group_only_toggled", { group: g, only: (onlyGroup === g) }); });

        const eyeBtn = document.createElement("button"); eyeBtn.className = "iconbtn eye-toggle"; eyeBtn.title = groupState[g].faded ? "Show group at full opacity" : "Fade this group"; eyeBtn.innerHTML = groupState[g].faded ? svgEyeOff() : svgEye();
        eyeBtn.addEventListener("click", (e)=>{
          e.stopPropagation(); groupState[g].faded = !groupState[g].faded; head.classList.toggle("faded", groupState[g].faded);
          eyeBtn.innerHTML = groupState[g].faded ? svgEyeOff() : svgEye(); eyeBtn.title = groupState[g].faded ? "Show group at full opacity" : "Fade this group";
          applyFilters(false); // updates icon-opacity via feature property
        });

        const chevBtn = document.createElement("button"); chevBtn.className = "iconbtn"; chevBtn.innerHTML = svgChevron();
        controls.appendChild(onlyBtn); controls.appendChild(eyeBtn); controls.appendChild(chevBtn);
        head.appendChild(titleWrap); head.appendChild(controls); section.appendChild(head);

        const body = document.createElement("div"); body.className = "group-body";
        if (groupState[g].collapsed) head.classList.add("collapsed");
        if (groupState[g].faded) body.classList.add("faded");
        head.addEventListener("click", (e)=>{ if (e.target.closest(".eye-toggle") || e.target === onlyBtn) return; groupState[g].collapsed = !groupState[g].collapsed; head.classList.toggle("collapsed", groupState[g].collapsed); });

        grouped.get(g).forEach((p, idx)=>{
          const item = document.createElement("div"); item.className = "card"; if (groupState[g].faded) item.classList.add("faded");
          const iconSrc = resolveIconSrc(p); const iconEl = iconSrc ? '<img class="pin-img" src="'+iconSrc+'" alt=""/>' : '';
          item.innerHTML = iconEl + '<div><h4>'+escapeHtml(p.name)+'</h4><div class="meta">'+(p.tags||[]).join(' · ')+'</div></div>';
          item.addEventListener("click", ()=>{
            // center & popup by searching rendered feature with same name & group (best-effort)
            const src = map.getSource(placesSourceId); if (!src) return;
            // Ask the source’s current data
            const data = src._data || src._options?.data; if (!data) return;
            const f = (data.features || []).find(fe => fe.properties && fe.properties.name === p.name && fe.properties.group === p.group);
            if (!f) return;
            const coords = f.geometry.coordinates;
            map.easeTo({ center: coords, zoom: Math.max(map.getZoom(), 17), duration: 500 });
            setTimeout(()=>{
              if (popup) popup.remove();
              popup = new maplibregl.Popup({ closeOnClick: true, maxWidth: getComputedStyle(document.documentElement).getPropertyValue('--iw-w') || '320px' })
                .setLngLat(coords).setHTML(f.properties.html).addTo(map);
            }, 520);
          });
          body.appendChild(item);
        });

        section.appendChild(body); list.appendChild(section);
      });

      $("#summary").textContent = places.length + " place" + (places.length===1 ? "" : "s") + " shown";
    }

    function currentMatches() {
      const q = $("#search").value.trim().toLowerCase();
      const activeTags = new Set($$("#tag-filters input:checked").map((i)=> i.value));
      const matches = [];
      allPlaces.forEach((place) => {
        let ok = true;
        if (onlyGroup && (place.group !== onlyGroup)) ok = false;
        if (ok && activeTags.size > 0) {
          const ptags = place.tagsNorm || [];
          ok = ptags.some((t)=> activeTags.has(t));
        }
        if (ok && q) {
          const hay = (place.name + " " + place.group + " " + (place.tags||[]).join(" ") + " " + place.keywordsText).toLowerCase();
          if (hay.indexOf(q) === -1) ok = false;
        }
        if (ok) matches.push(place);
      });
      if (userPos && $("#sort").value === 'distance') {
        matches.forEach((p)=> p._distanceM = haversine(userPos, {lat: p.lat, lng: p.lng}));
        matches.sort((a,b)=> a._distanceM - b._distanceM);
      } else {
        matches.sort((a,b)=> a.name.localeCompare(b.name));
      }
      return matches;
    }

    async function rebuildMapData(places) {
      // prepare icons
      const icons = uniqueIconsFor(places);
      if (icons.length) await loadImages(map, icons);
      if (!map.hasImage('default-pin')) {
        const c = document.createElement('canvas'); c.width=36; c.height=36; const ctx=c.getContext('2d'); ctx.fillStyle='#4A00E2'; ctx.beginPath(); ctx.arc(18,18,8,0,Math.PI*2); ctx.fill();
        map.addImage('default-pin', c, { pixelRatio: 2 });
      }
      const adjusted = spreadCoincidentPlaces(places, 20);
      const geojson = toGeoJSON(places, adjusted);
      addOrUpdateSourceAndLayers(geojson);
      return geojson;
    }

    async function applyFilters(fitNow) {
      const matches = currentMatches();
      renderList(matches);
      const geojson = await rebuildMapData(matches);
      $("#summary").textContent = matches.length + " place" + (matches.length===1 ? "" : "s") + " shown";
      if (fitNow !== false) fitToGeoJSON(geojson);
      trackFP("filter_applied", { query: ($('#search')?.value||'').trim(), groups_active: Array.from(new Set(matches.map(p=>p.group))).slice(0,10), results_count: matches.length });
    }

    // Drawer & controls
    const menuBtn   = document.querySelector('.menu-btn');
    const sidebarEl = document.getElementById('sidebar');
    const backdrop  = document.querySelector('.backdrop');
    function openDrawer() { sidebarEl.classList.add('open'); backdrop.classList.add('show'); menuBtn.setAttribute('aria-expanded', 'true'); document.body.style.overflow = 'hidden'; }
    function closeDrawer() { sidebarEl.classList.remove('open'); backdrop.classList.remove('show'); menuBtn.setAttribute('aria-expanded', 'false'); document.body.style.overflow = ''; }
    if (menuBtn && sidebarEl && backdrop) {
      menuBtn.addEventListener('click', ()=>{ if (sidebarEl.classList.contains('open')) { closeDrawer(); } else { openDrawer(); } });
      backdrop.addEventListener('click', closeDrawer);
    }
    function getUserLocation() {
      return new Promise((resolve, reject)=>{
        if (!navigator.geolocation) return reject(new Error('No geolocation'));
        navigator.geolocation.getCurrentPosition(
          (pos)=> resolve({ lat: pos.coords.latitude, lng: pos.coords.longitude }),
          (err)=> reject(err),
          { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
      });
    }

    // Init
    async function initApp() {
      try {
        initMap();
        if (APP.UI?.hideControls) document.getElementById('controls').style.display = 'none';
        if (APP.UI?.hideFilters)  document.getElementById('filters').style.display  = 'none';

        const rows = await fetchSheetRows();
        allPlaces = rows.map(normalizeRow).filter((p)=> Number.isFinite(p.lat) && Number.isFinite(p.lng));

        // Wait for map to be ready before adding images/layers
        map.once('load', async ()=>{
          buildFiltersUI(allPlaces);
          renderList(allPlaces);
          const initialGeo = await rebuildMapData(allPlaces);
          fitToGeoJSON(initialGeo);

          // Controls
          $('#search').addEventListener('input', ()=> applyFilters(true));
          $('#sort').addEventListener('change', ()=> applyFilters(true));
          $('#btn-reset').addEventListener('click', async ()=>{
            $$("#tag-filters input[type=checkbox]").forEach((i)=> i.checked = true);
            $('#search').value = '';
            $('#sort').value = 'name';
            onlyGroup = null;
            Object.keys(groupState).forEach((k)=> groupState[k] = { collapsed:false, faded:false });
            renderList(allPlaces);
            const gj = await rebuildMapData(allPlaces);
            fitToGeoJSON(gj);
            if (popup) { popup.remove(); popup = null; }
            closeDrawer();
            trackFP("reset_clicked", { restore_all: true });
          });

          $('#btn-nearme').addEventListener('click', async ()=>{
            try {
              const pos = await getUserLocation();
              userPos = pos;
              map.easeTo({ center: [pos.lng, pos.lat], zoom: Math.max(map.getZoom(), 12) });
              $('#sort').value = 'distance';
              applyFilters(true);
              trackFP("geolocate_clicked", { allowed: true });
            } catch {
              alert('Location permission was denied or unavailable.');
              trackFP("geolocate_clicked", { allowed: false });
            }
          });
        });
      } catch (err) {
        console.error(err);
        alert('Failed to initialize: ' + err.message);
      }
    }
    window.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>
</html>
